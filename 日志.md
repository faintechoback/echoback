
original：

        对于出入的设计方面存在一定缺陷，或者说是思路方面的失误，若对基础表部分不修改的话，
        对于imp这样的部分应该不能存在所谓的添加和删除，因为这些都是来自于购入表，
        同时，对购入deliver表进行入库操作后才有了所谓的imp表，添加操作应该只是针对于供货和交易与信息
        对于售出与入库应该没有增加删除操作，登陆部分或许可以加个注册功能，且设置密匙，若有密匙直接视为boss权限

        对于绝大部分的删除操作应该只有boss权限才拥有，对于普通员工应该只有出入库权限，也就是说右侧的工具栏只对老板开放
        其余应该隐藏
        pass,这样操作的话会导致哪怕是删除部分也只能根据id来删除

        对于出入库后各个表内的修改，应该是可以写个触发器，但是风险较高，因为涉及到多个表的变化，
        对于报损表，或许可以写个类似保质期的东西，，，，，shut up，不太行，因为可能会需要一定的时刻监听


        大致完成了基本的增删改查操作，但是发现原始设计存在不小的设计缺陷，删除按道理也只是在
        对于员工表需要保留，原本删去了，察觉到确实存在员工和boss的权限关系，而不是都笼统在一起

        对于key，依旧是直接equal，不分大小

对于sql的触发器，


报损表展示没有想到好方法
入库记录表imp删除视为售出，加个触发器，不存在删除操作，
//对于购入表deliver的删除操作视为入库，同样加个触发器，添加视为购入操作
shut up，删除不能视为入库，因为原始购入记录需要保留
信息表删除和添加不需要加个触发器，
但是在购入时，如果识别未存在该进货商信息，自动添加信息，只不过其他基本信息为null
售出的话，可能考虑需要写个对话框，指定售出对象，但是应该还是不存在删除操作
在删除的时候可


/////对于字段的自增参考值，：参照表内该字段最大值进行自增，且不论是删除过与否
察觉到，当我使用触发器向其他表内添加数据时，由于自增的存在，如果我对原先表内数据全部删除完毕后，字段的自增初始值依旧回到删除前的最大值
如果只是触发器的话，会发现无法修改表的结构，也就是说无法自动修改自增，但是存储过程可以，也就是说，可以在触发器中调用存储过程，实现间接修改
字段的自增初始值；且
对于删除操作的触发器，不论是删除前，还是删除后，old。id都会识别为被删除数据的id字段

但是在实际中发现哪怕是触发器调用存储过程也会出现无法修改表的结构，不能去手动修改自增初始值，因此肯能需要直接在原本表内的删除语句附加执行存储过程，但是无参





        
